
# æŒ‡æ•°ä¸å–æ¨¡

> **é¢˜ç›®æ¥æº**ï¼šæ´›è°· P4317 èŠ±ç¥çš„æ•°è®ºé¢˜  
> **æ ¸å¿ƒæ•™è®­**ï¼š**ä½œä¸ºæŒ‡æ•°çš„è®¡æ•°ç»“æœï¼Œç»å¯¹ä¸èƒ½æå‰å–æ¨¡ï¼**

---

## ğŸ“Œ é¢˜ç›®æè¿°

è®¾ $\text{sum}(i)$ è¡¨ç¤º $i$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ $1$ çš„ä¸ªæ•°ã€‚ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° $N$ï¼Œæ±‚ï¼š
$$
\prod_{i=1}^{N} \text{sum}(i) \mod 10000007
$$

### è¾“å…¥æ ¼å¼
ä¸€ä¸ªæ­£æ•´æ•° $N$ï¼ˆ$1 \le N \le 10^{15}$ï¼‰ã€‚

### è¾“å‡ºæ ¼å¼
ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­”æ¡ˆæ¨¡ $10000007$ çš„å€¼ã€‚

### æ ·ä¾‹
**è¾“å…¥**ï¼š
```
3
```
**è¾“å‡º**ï¼š
```
2
```
**è§£é‡Š**ï¼š  
- $\text{sum}(1) = 1$  
- $\text{sum}(2) = 1$  
- $\text{sum}(3) = 2$  
- ä¹˜ç§¯ä¸º $1 \times 1 \times 2 = 2$

---

## âœ… æ­£ç¡®æ€è·¯

1. **é—®é¢˜è½¬åŒ–**ï¼š  
   ç»Ÿè®¡åœ¨ $[1, N]$ ä¸­ï¼ŒäºŒè¿›åˆ¶æ°å¥½æœ‰ $c$ ä¸ª $1$ çš„æ•°çš„ä¸ªæ•°ï¼Œè®°ä¸º $\text{cnt}[c]$ã€‚  
   åˆ™ç­”æ¡ˆä¸ºï¼š
   $$
   \prod_{c=1}^{\text{max\_bit}} c^{\text{cnt}[c]} \mod 10000007
   $$

2. **æ•°ä½ DP**ï¼š  
   ä½¿ç”¨æ•°ä½ DPï¼ˆæˆ–ç»„åˆé€’æ¨ï¼‰è®¡ç®— $\text{cnt}[c]$ã€‚  
   - çŠ¶æ€ï¼š`dfs(pos, ones, tight)`  
     - `pos`ï¼šå½“å‰å¤„ç†åˆ°ç¬¬å‡ ä½  
     - `ones`ï¼šè¿˜éœ€è¦æ”¾ç½®å¤šå°‘ä¸ª 1  
     - `tight`ï¼šæ˜¯å¦ä»å— $N$ çš„ä¸Šç•Œé™åˆ¶  
   - **å…³é”®**ï¼šDP è¿”å›çš„æ˜¯**ç²¾ç¡®è®¡æ•°ï¼Œéœ€è¦ä½œä¸ºæŒ‡æ•°**ï¼Œä¸èƒ½å–æ¨¡ï¼

3. **å¿«é€Ÿå¹‚**ï¼š  
   å¯¹æ¯ä¸ª $c$ï¼Œè®¡ç®— $c^{\text{cnt}[c]} \mod 10000007$ã€‚  
   - **åº•æ•° $c$** å¯ä»¥å–æ¨¡  
   - **æŒ‡æ•° $\text{cnt}[c]$ å¿…é¡»æ˜¯ç²¾ç¡®å€¼**ï¼ˆä¸èƒ½å–æ¨¡ï¼ï¼‰

---

## âŒ æˆ‘çš„é”™è¯¯ä»£ç 

```cpp
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::vector;

using i64 = long long;
using u64 = unsigned long long;
constexpr i64 MOD = 10000007;

struct solve {
    vector<int> n;
    vector<vector<i64>> memo;
    solve(i64 num) {
        int L = num ? 64 - __builtin_clzll(num) : 1;
        n.resize(L);
        for (int i = L - 1; i >= 0; --i, num >>= 1) n[i] = (num & 1);
        memo.assign(L, vector<i64>(L + 1, -1));
    }
    i64 dfs(int i, int curr, bool same) {
        if (i == (int)n.size() || curr <= 0) {
            return (curr == 0) ? 1LL : 0LL;
        }
        if (!same && memo[i][curr] != -1) {
            return memo[i][curr];
        }
        i64 res = 0;
        if (same) {
            if (n[i] == 0) {
                res += dfs(i + 1, curr, true);
                res %= MOD;  // âŒ é”™è¯¯ï¼šå¯¹è®¡æ•°å–æ¨¡ï¼
            } else {
                res += dfs(i + 1, curr, false);
                res %= MOD;  // âŒ é”™è¯¯ï¼šå¯¹è®¡æ•°å–æ¨¡ï¼
                res += dfs(i + 1, curr - 1, true);
                res %= MOD;  // âŒ é”™è¯¯ï¼šå¯¹è®¡æ•°å–æ¨¡ï¼
            }
        } else {
            res += dfs(i + 1, curr, false);
            res %= MOD;  // âŒ é”™è¯¯ï¼šå¯¹è®¡æ•°å–æ¨¡ï¼
            res += dfs(i + 1, curr - 1, false);
            res %= MOD;  // âŒ é”™è¯¯ï¼šå¯¹è®¡æ•°å–æ¨¡ï¼
            memo[i][curr] = res;
        }
        return res;
    }
    i64 count(int c) {
        for (auto &v : memo) std::fill(v.begin(), v.end(), -1);
        return dfs(0, c, true);
    }
};

i64 mypow(i64 a, i64 b) {
    i64 res = 1 % MOD;
    a %= MOD;
    while (b) {
        if (b & 1) res = (res * a) % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res % MOD;
}

int main() {
    u64 n;
    cin >> n;
    solve a(n);
    i64 res = 1;
    int mx = n ? 64 - __builtin_clzll(n) : 1;
    for (int i = 2; i <= mx; i++) {
        // âŒ é”™è¯¯ï¼šå¯¹æŒ‡æ•°å–æ¨¡ï¼
        res = res * mypow(i % MOD, a.count(i) % MOD) % MOD;
    }
    cout << res << endl;
}
```

---

## ğŸ” é”™è¯¯åŸå› åˆ†æ

### æ ¹æœ¬åŸå› 
> **åœ¨æ•°ä½ DP çš„ `dfs` å‡½æ•°ä¸­ï¼Œå¯¹è®¡æ•°ç»“æœå–äº†æ¨¡ `MOD`ï¼Œå¯¼è‡´ `count(c)` è¿”å›çš„æ˜¯ `çœŸå®æ•°é‡ % MOD`ï¼Œè€ŒéçœŸå®æ•°é‡ã€‚**

### ä¸ºä»€ä¹ˆè¿™æ˜¯è‡´å‘½çš„ï¼Ÿ
- å¿«é€Ÿå¹‚çš„æŒ‡æ•°å¿…é¡»æ˜¯**ç²¾ç¡®çš„è®¡æ•°å€¼**ã€‚
- ä¾‹å¦‚ï¼šè‹¥çœŸå®è®¡æ•°ä¸º `10000008`ï¼Œå–æ¨¡åå˜ä¸º `1`ï¼Œåˆ™ï¼š
  - æ­£ç¡®è®¡ç®—ï¼š$ c^{10000008} \mod 10000007 $
  - é”™è¯¯è®¡ç®—ï¼š$ c^{1} \mod 10000007 $
- ä¸¤è€…ç»“æœå®Œå…¨ä¸åŒï¼

---

## âœ… æ­£ç¡®ç‰ˆæœ¬ä»£ç 

```cpp
#include<bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::vector;

using i64 = long long;
using u64 = unsigned long long;
constexpr i64 MOD = 10000007;

struct solve{
    vector<int> n;
    vector<vector<i64>> memo;
    solve(u64 num){
        int L = num ? 64 - __builtin_clzll(num) : 1;
        n.resize(L);
        for (int i = L - 1; i >= 0; --i, num >>= 1) n[i] = (num & 1);
        memo.assign(L, vector<i64>(L + 1, -1));
    }
    i64 dfs(int i,int curr,bool same){
        if (i == n.size() || curr <= 0) {
            return (curr == 0) ? 1LL : 0LL;
        }
        if(!same && memo[i][curr] != -1){
            return memo[i][curr];
        }
        i64 res = 0;
        if(same){
            if(n[i]==0){
                res += dfs(i+1,curr,true);
                // res %= MOD;
            }
            else{
                res += dfs(i+1,curr,false);
                // res %= MOD;
                res += dfs(i+1,curr-1,true);
                // res %= MOD;
            }
        }else{
            res += dfs(i+1,curr,false);
            // res %= MOD;
            res += dfs(i+1,curr-1,false);
            // res %= MOD;
            memo[i][curr] = res;
        }
        return res;
    }
    i64 count(int c){
        for (auto &v : memo) std::fill(v.begin(), v.end(), -1);
        return dfs(0,c,true);
    }
};

i64 mypow(i64 a,i64 b){
    i64 res = 1 % MOD;
    a %= MOD;
    while (b) {
        if (b & 1) res = (res * a) % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res%MOD;
}

int main(){
    u64 n ;
    cin>>n;
    solve a(n);
    i64 res = 1;
    int mx = n ? 64 - __builtin_clzll(n) : 1;
    for(int i = 2;i <= mx;i++){
        i64 cnt = a.count(i);
        if (cnt == 0) continue;
        res = res * mypow(i % MOD, cnt) % MOD;  // ä¸å¯¹ cnt å–æ¨¡ï¼
    }
    cout<<res<<endl;

}
```