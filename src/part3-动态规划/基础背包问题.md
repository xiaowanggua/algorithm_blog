# 背包问题算法讲解

## 01背包问题

01背包问题是最基础的背包问题，特点是每种物品只有一件。
在处理每一件物品的时候，我们只有一种考虑的方案--选择这件物品或者不选择。
如果我们选择这种物品消耗`c[i]`的资源，得到`v[i]`的收益
因此，如果我们`面对第i个物品，拥有j的资源的时候`，便可以将问题转化为
我在`不买这个物品`和`买下这个物品`哪种选择的收益更高
如果我们以`dp[i][j]`表示上述的`"面对第i个物品，拥有j的资源的时候"`时能得到的最大收益
那这个`dp[i][j]`就可以被转化为在`dp[i-1][j]`与`dp[i-1][j-c[i]]+v[i]`中选择较大那个
因此，状态转移方程即为
`dp[i+1][j] = max(dp[i][j],dp[i][j-c[i]]+v[i])`

### 代码解析
(下面的代码我直接使用了滚动数组优化)
```c++
vector<int> dp(t+1); 
// 创建动态规划数组，
// dp[j]表示容量为j时的最大价值
for(int i=0;i<m;++i){ // 遍历所有物品
    for(int j=t;j>=cost[i];--j){ 
        // 从大到小遍历背包容量
        dp[j]=max(dp[j],dp[j-cost[i]]+value[i]); 
        // 状态转移方程
    }
}
```

### 关键点
1. **状态定义**：`dp[j]`表示背包容量为j时能获得的最大价值
2. **状态转移**：对于每个物品，考虑放入或不放入两种情况
3. **逆序遍历**：必须从大到小遍历背包容量，确保每个物品只被使用一次
下面给出“完全背包”部分的完整展开，完全对标你已有的“01背包”写法。你可以直接替换或合并到原笔记中，保持风格一致。

---

## 完全背包问题

完全背包问题在01背包的基础上，把「每种物品只有1件」放宽为「每种物品有∞件」。  
因此，当我们**面对第i个物品、拥有j的资源时**，决策不再是“拿或不拿”，而是**“拿0件、拿1件、拿2件……直到背包放不下”**。  
如果我们沿用`dp[i][j]`表示“仅考虑前i种物品、背包容量为j时能获得的最大价值”，那么状态转移可以写成  
$dp[i+1][j] = max_{k≥0}(dp[i][j−k·c[i]] + k·v[i])$，其中$k·c[i] ≤ j$。  

直接枚举k会超时，但注意到  
`dp[i+1][j] = max(dp[i][j], dp[i+1][j−c[i]] + v[i])`  
——后者已经包含了“再拿1件”的决策，因为`dp[i+1][j−c[i]] + v[i]`并没有移动物品的指针，因此我们实际上拿完当前这个东西，实际上是在考虑“再拿一个，或者选择拿下一个”
于是得到和01背包**形式完全一样**、但**遍历顺序相反**的经典方程：

`dp[i+1][j] = max(dp[i][j], dp[i+1][j−c[i]] + v[i])`

### 代码解析（滚动数组优化）
```cpp
vector<int> dp(t + 1);          // dp[j]：容量为j时的最大价值
for (int i = 0; i < m; ++i) {   // 遍历所有物品
    for (int j = cost[i]; j <= t; ++j) {  // 从小到大枚举容量
        dp[j] = max(dp[j], dp[j - cost[i]] + value[i]); // 状态转移
    }
}
```

### 关键点
1. **状态定义**：同01背包，`dp[j]`表示容量为j时的最大价值。  
2. **状态转移**：方程形式与01背包相同，但**第二维引用的是“本行”刚刚更新过的值**，从而隐含“无限次使用”。  
3. **正序遍历**：从小到大枚举容量，保证`dp[j−c[i]]`在本轮**已经更新过**，即允许当前物品被重复使用。  

### 记忆口诀
> **01背包逆着跑，完全背包顺着扫；方程一样顺序反，无限次数自然到。**