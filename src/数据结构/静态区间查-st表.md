## 📖 算法讲解

### 1. 问题模型  
给定一个长度为 `n` 的**静态数组** `a[0…n-1]`，接下来有 `m` 次询问，每次给出区间 `[l,r]`，要求**快速回答**该区间内的最大值（或最小值）。  
数组**不会中途修改**，只有查询。若数组频繁更新，请转线段树 / 树状数组。

---

### 2. ST 表思想  
ST 表（Sparse Table，稀疏表）是一套 **O(n log n) 预处理、O(1) 单次查询** 的离线算法，核心在于「**二进制拆分 + 倍增覆盖**」。

1. 预处理  
   令 `st[k][i]` 表示从位置 `i` 开始、长度为 `2^k` 的区间最值。  
   显然 `st[0][i] = a[i]`（长度为 1）。  
   对于更大的 `k`，把区间拆成左右**等长**两半：  
   `st[k][i] = max(st[k-1][i], st[k-1][i + 2^(k-1)])`  
   这样一层层「倍增」上去，共计算 `log n` 层。

2. 查询  
   对于任意 `[l,r]`，令 `len = r-l+1`，取 `k = floor(log2(len))`。  
   把原区间变成**两段长度为 2^k 的覆盖区间**，它们**允许重叠**：  
   `max = max(st[k][l], st[k][r - 2^k + 1])`  
   由于最值运算具有「**幂等性**」（重复取最值不影响结果），重叠毫无问题。  
   于是只要两次查表即可得出答案，妥妥的 O(1)。

正确性一句话：  
「二进制拆分」保证任意长度 `len` 一定能被两个 `2^k` 块完全覆盖；  
「幂等性」保证重叠部分不会污染结果。

---

### 3. 代码走读
下面给出**最大值版** ST 表，读入外挂 `read()` 已省略。

```c++
int main(){
    int n,m;
    n = read();                      // 数组长度
    m = read();                      // 查询次数
    vector<int> a(n);
    for(int i = 0;i < n;++i){
        a[i] = read();               // 读入原始数组
    }

    /* ---------- 1. 预处理 ---------- */
    int max_bit = std::log2(n+1) + 1;  // 最大需要倍增到的 k
    vector<vector<int>> st(max_bit, vector<int>(n+1));
    for(int i = 0;i < n;++i){
        st[0][i] = a[i];             // 长度为 1 的区间就是自己
    }
    for(int k = 1; k < max_bit; ++k){
        int step = 1 << (k-1);       // 右半段起始偏移
        for(int i = 0; i + (1<<k) <= n; ++i){
            st[k][i] = max(st[k-1][i], st[k-1][i + step]);
        }
    }

    /* ---------- 2. 回答查询 ---------- */
    while(m-->0){
        int l,r;
        l = read(); r = read();
        --l;                         // 个人习惯转 0-based
        int len = r - l;             // 注意这里 r 是闭区间右端
        int k = std::log2(len);
        int r_f = r - (1<<k);        // 右段左端
        int res = max(st[k][l], st[k][r_f]);
        printf("%d\n",res);
    }
}
```

---

### 4. 复杂度算账
把复杂度拆成**两块**就一目了然：

1. 预处理  
   共 `log n` 层，第 `k` 层需要扫 `n - 2^k + 1` 个位置 → 总体  
   `O(n log n)`

2. 单次查询  
   仅两次查表 + 一次 `log2`（可换 `__builtin_clz` 做到 O(1)）→  
   `O(1)` 无疑

因此  
- 预处理：`O(n log n)`  
- `m` 次查询：`O(m)`  
总时间 `O(n log n + m)`，空间 `O(n log n)`。

---

### 5. 使用小贴士
- ST 表**只适用于静态数组**，一旦原数组改动就要重新预处理。  
- 运算必须满足「**可重复贡献**」：max、min、gcd、bitand/or 等都可以；  
  和、异或等不行，因为重叠会让结果出错。  
- 如果 `n` 很大但 `m` 更大，ST 表相比线段树常数更小、代码更短；  
  反之若 `n` 与 `m` 同阶且需要修改，请上线段树。