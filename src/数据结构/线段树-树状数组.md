在这里给出一个线段树/树状数组的通用模板类
遇到相关题目的时候直接把它打上去，然后填写4个functor（伪函数）就可以直接用了
```c++
#include <bits/stdc++.h>
using namespace std;

/* ---------------- 通用线段树 ---------------- */
template <
    class ValType,      // 结点值类型
    class LazyType,     // 延迟标记类型
    class GetVal,       // 从 nums[i] 提取 ValType
    class Merge,        // ValType merge(ValType, ValType)
    class UpdateLazy,   // void updateLazy(LazyType& son, LazyType fa)
    class PushDown      // void pushDown(ValType& val, LazyType& lazy, int len)
>
class SegTree {
private:
    struct Node {
        int l, r;           // 区间 [l, r)
        int ls, rs;         // 左右孩子下标
        ValType val;        // 结点值
        LazyType lazy;      // 延迟标记
        Node() = default;
        Node(int l_, int r_, int ls_, int rs_, const ValType& v_, const LazyType& z_)
            : l(l_), r(r_), ls(ls_), rs(rs_), val(v_), lazy(z_) {}
    };

    int n;
    vector<Node> tr;
    GetVal   getVal;
    Merge    merge;
    UpdateLazy updateLazy;
    PushDown pushDown;

    /* 新建一个结点并返回下标 */
    int newNode(int l, int r) {
        tr.emplace_back(l, r, -1, -1, ValType{}, LazyType{});
        return (int)tr.size() - 1;
    }

    /* 递归建树 */
    int build(const auto& nums, int l, int r) {
        int id = newNode(l, r);
        if (l + 1 == r) {                       // 叶子
            tr[id].val = getVal(nums[l]);
            return id;
        }
        int mid = (l + r) >> 1;
        int ls = build(nums, l, mid);
        int rs = build(nums, mid, r);
        tr[id].ls = ls; tr[id].rs = rs;
        tr[id].val = merge(tr[ls].val, tr[rs].val);
        return id;
    }

    /* 下推 lazy */
    void doPush(int id) {
        if (tr[id].l + 1 == tr[id].r) return;   // 叶子无需下推
        int ls = tr[id].ls, rs = tr[id].rs;
        /* 先修正子节点的 lazy */
        updateLazy(tr[ls].lazy, tr[id].lazy);
        updateLazy(tr[rs].lazy, tr[id].lazy);
        /* 再修正子节点的 val */
        int llen = tr[ls].r - tr[ls].l;
        int rlen = tr[rs].r - tr[rs].l;
        pushDown(tr[ls].val, tr[id].lazy, llen);
        pushDown(tr[rs].val, tr[id].lazy, rlen);
        /* 清空当前 lazy */
        tr[id].lazy = LazyType{};
    }

    /* 区间查询 [l, r) */
    ValType query(int l, int r, int id) {
        if (tr[id].l == l && tr[id].r == r) return tr[id].val;
        doPush(id);
        int mid = (tr[id].l + tr[id].r) >> 1;
        if (r <= mid)      return query(l, r, tr[id].ls);
        else if (l >= mid) return query(l, r, tr[id].rs);
        else return merge(query(l, mid, tr[id].ls),
                          query(mid, r, tr[id].rs));
    }

    /* 区间更新 [l, r) */
    void modify(int l, int r, const LazyType& val, int id) {
        if (tr[id].l == l && tr[id].r == r) {
            updateLazy(tr[id].lazy, val);
            pushDown(tr[id].val, val, tr[id].r - tr[id].l);
            return;
        }
        doPush(id);
        int mid = (tr[id].l + tr[id].r) >> 1;
        if (r <= mid)      modify(l, r, val, tr[id].ls);
        else if (l >= mid) modify(l, r, val, tr[id].rs);
        else {
            modify(l, mid, val, tr[id].ls);
            modify(mid, r, val, tr[id].rs);
        }
        tr[id].val = merge(tr[tr[id].ls].val, tr[tr[id].rs].val);
    }

public:
    /* 构造函数：传入原始数组 */
    template <class Arr>
    SegTree(const Arr& nums) {
        n = nums.size();
        build(nums, 0, n);
    }

    /* 查询 [l, r) */
    ValType get(int l, int r) { return query(l, r, 0); }

    /* 更新 [l, r) */
    void update(int l, int r, const LazyType& val) { modify(l, r, val, 0); }
};
/* ---------------- 通用线段树结束 ---------------- */

/* ---------- 以下以「区间加 + 区间 max」为例 ---------- */
using i64 = long long;
struct Max {                // 合并器
    i64 operator()(i64 a, i64 b) const { return max(a, b); }
};
struct Add {                // 更新 lazy：加法
    void operator()(i64& son, i64 fa) const { son += fa; }
};
struct Apply {              // 将 lazy 作用到当前节点值
    void operator()(i64& val, i64 lazy, int len) const { val += lazy; }
};
struct Id {                 // 从原数组提取值
    i64 operator()(i64 x) const { return x; }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    cin >> n >> q;
    vector<i64> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    /* 实例化线段树 */
    SegTree<i64, i64, Id, Max, Add, Apply> st(a);

    while (q--) {
        int op, l, r;
        cin >> op >> l >> r;
        --l;
        if (op == 0) {
            ll v; cin >> v;
            st.update(l, r, v);          // 区间 [l, r) 加 v
        } else {
            cout << st.get(l, r) << '\n';// 区间 [l, r) 最大值
        }
    }
    return 0;
}
```