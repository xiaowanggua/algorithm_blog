## 前情提要：
- dijkstra算法的复杂度:    $O((m+n)*log(n))$
- Bellmen-ford 复杂度:  $O(m*n)$

这些算法有如下缺点：
1. 复杂度依赖边数m，当边数$m = O(n^2)$时，整体算法的复杂度会接近$O(n^2*log(n))$与$O(n^3)$
2. 算法只能求单源到所有点的距离，如果要求任意两点之间的距离，那就只能n次调用上述算法，最差复杂度来到了$O(n^3log(n))$与$O(n^4)$，完全无法接受

# Floyd算法（弗洛伊德算法）
## 算法核心介绍
### 算法核心
这个算法的核心非常接近**动态规划**
算法的核心思想非常简单：
对于任意两个点$i,j$，我们可以选取一个点$k$，并且将连通$i,j$的全体路径分为两类：
- 经过$k$的
- 不经过的$k$的

假设我们使用$dp[k][i][j]$来表示$i,j$之间的，**不经过大于$k$的点**的最短路长度，那么它便只可能从两种状态转移而来：
- 最短路上没有k，保留$dp[k-1][i][j]$；
- 或者最短路经过k了，为$dp[k-1][i][k]+dp[k-1][k][j]$

那么，核心的状态转移方程即
$dp[k][i][j] = min(dp[k-1][i][j],dp[k-1][i][k]+dp[k-1][k][j])$
### 空间优化
显然，当前代码的空间复杂度是$O(n^3)$，太不优雅
我们可以注意到，由于$dp[i][i] = 0$总是成立的（因为自己到自己的距离总是0），
因此有：
- $dp[k][i][k] = min(dp[k-1][i][k],dp[k-1][i][k] + dp[k-1][k][k]) = dp[k-1][i][k]$,
- 同理：$dp[k][k][j] = dp[k-1][k][j]$

因此，不难发现，类似于滚动数组优化，我们完全没有必要保留第一个k数组--
- 如果从$dp[k-1][i][j]$转移而来，那本地就是原来的值；
- 如果从后者转移而来，更新前后两项的数值都没有任何差异。

因此我们可以做出优化，省略掉k数组，将空间复杂度优化到$O(n^2)$。
## 核心代码
```c++
using i64 = long long;
constexpr i64 INF = std::numeric_limits<i64>::max();
std::vector<std::vector<i64>>dp(n+1,std::vector<i64>(n+1,INF));
// 此处构建邻接矩阵
for(int k = 1;k <= n; ++k){
    for(int i = 1;i <= n; ++i){
        for(int j = 1;j <= n; ++j){
            if(dp[i][k] < INF && dp[k][j] < INF)
                dp[i][j] = std::min(dp[i][j],dp[i][k]+dp[k][j]);
        }      
    }
}
```