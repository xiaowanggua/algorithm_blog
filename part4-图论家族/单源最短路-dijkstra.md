
## 📖 算法讲解

### 1. 问题模型
给定带权有向图 `G=(V,E)`，源点 `s`，求 `s` 到所有其它顶点的最短路径长度（权值和最小）。  
允许权值为正，**不允许负权边**（否则需 Bellman-Ford/SPFA）。

---

### 2. Dijkstra 思想
1. 维护一个「已确定最短路径」的集合 `S`，初始只有 `s`。  
2. 每次从 `V-S` 中挑选一个「距离源点最近」的顶点 `u`，加入 `S`。  
3. 用 `u` 的所有出边做**松弛操作**（relax）：  
   若 `dist[u] + w(u,v) < dist[v]`，则更新 `dist[v]`。  
4. 重复第 2 步直到所有顶点都在 `S` 中。

正确性证明依赖于「非负权」下的贪心选择性质：当前堆顶挑出的 `u` 已经不可能被后续节点再次松弛出更小的值：
假定一个节点能够被以两条路径到达，不妨设第一条路径为直接到达，权值为100，第二条路径为绕99个节点到达，每个节点权值为1。
在这种情况下，由于每次堆顶弹出从初始点到对应节点的权值最小的那一条路径，因此它每次都会优先弹出绕路的路径。
（即使是最后一个节点，绕路的路径的j依然是99，小于直接走的100）
因此，我们可以确认，堆顶首次弹出的方案就是最优的

```c++
#include <bits/stdc++.h>
using i64 = long long;
struct Edge{
    int to;
    i64 w;
    bool operator<(const Edge& b)const{
        return w > b.w;
        //为了获得最小堆，需要反过来
    }
    Edge(int t,i64 w)
        :to(t),w(w){
    }
};
int main(){
    i64 n,m,s;
    std::cin>>n>>m>>s;
    std::vector<std::vector<Edge>> conn(n+1);
    // 初始化邻接矩阵
    for(int i = 0;i < m;++i){
        int a,b,c;
        std::cin>>a>>b>>c;
        conn[a].push_back({b,c}); 
    }
    // 建立图
    std::priority_queue<Edge> q;
    // 优先队列，保证每次弹出的都是距离已经更新的节点最近的节点
    q.push({s,0});
    // 优先队列中压入初始节点
    std::vector<i64> minDistance(n+1,std::numeric_limits<i64>::max());
    // 结果向量，存储初始节点到每个节点的最短路径，初始化为正无穷
    minDistance[s] = 0;
    // 将初始节点到自己的距离设置为0
    std::vector<char> vis(n+1,0);
    // vis向量，避免重复更新
    while(!q.empty()){
        auto [i,j] = q.top();q.pop();
        // 获取堆顶的节点（即距离已更新节点最近的节点）
        // i代表当前节点索引，j代表从初始节点到i节点的最小权值
        if(vis[i])continue;
        vis[i] = 1;
        // 注意：不写这个vis依然能得到正确结果，但是它会tle
        // 假定一个节点能够被以两条路径到达，不妨设第一条路径为直接到达，权值为100，第二条路径为绕99个节点到达，每个节点权值为1
        // 在这种情况下，由于每次堆顶弹出从初始点到对应节点的权值最小的那一条路径，因此它每次都会优先弹出绕路的路径
        // （即使是最后一个节点，绕路的路径的j依然是99，小于直接走的100）
        // 因此，我们可以确认，如果堆顶弹出这个节点，那么这个节点一定已经是最优的节点
        // （但是，作为其他节点的子节点，确实可能被更新多次）
        for(auto [a,b]:conn[i]){
            // 通过邻接矩阵访问当前节点链接的节点
            // a代表下一个节点的索引，b代表距离下一个节点的距离
            if(minDistance[a] > j + b){
                // 如果通过当前路径能更短的到达下一个节点，那么就更新
                minDistance[a] = j + b;
                q.push({a,minDistance[a]});
            }
        }
    }
    for(int i = 1;i <= n;++i){
        std::cout<<minDistance[i]<<" ";
    }
    std::cout<<std::endl;
    return 0;
}

```
### 复杂度计算
把复杂度拆成**两部分**看就清楚了：

1. 每个顶点**最多进堆一次**  
   共 `n` 个顶点 → 堆中插入/弹出 `n` 次，每次 `O(log n)`  
   合计 `O(n log n)`

2. 每条边**最多触发一次松弛并成功更新**  
   共 `m` 条边 → 每次更新要把新距离 `push` 进堆，`O(log n)`  
   合计 `O(m log n)`

把两部分相加就是  
`O(n log n + m log n) = O((n + m) log n)`
  
- 当图**稀疏**（`m ≈ n`）时，复杂度由 `n log n` 主导；  
- 当图**稠密**（`m ≈ n²`）时，复杂度由 `m log n` 主导。  
