#include <iostream>
#include <string>
#include <vector>
#include <cmath>
using namespace std;
#define ll long long
#include <algorithm>
#include <queue>

void solve(){
    int n,w,k;
    cin>>n>>w>>k;
    vector<pair<int,ll>> a(n);
    for(int i = 0;i<n;++i){
        cin>>a[i].first>>a[i].second;
    }

    sort(a.begin(),a.end());  //我们按照wi来从小到大排序。

    //记录每一个位置i，从i到n的前k个最大的vi和。
    vector<ll> maxsumk(n+1,0);
    priority_queue<ll,vector<ll>,greater<ll>> pq;
    ll curksum = 0;
    for(int i = n-1;i>=0;i--){
        ll v = a[i].second;
        pq.push(v);
        curksum+=v;

        if(pq.size()>k){
            curksum-=pq.top();
            pq.pop();
        }
        maxsumk[i] = curksum;
    }
    
    //dp[x]为还剩x元的时候价值的最大值
    vector<ll> dp(w+1,0);
    ll ans = maxsumk[0];
    for(int i = 0;i<n;++i){
        int wi = a[i].first;
        ll vi = a[i].second;

        for(int j = w;j>=wi;--j){
            dp[j] = max(dp[j],dp[j-wi]+vi);
        }

        //找到当前最大的前半部分的价值
        ll max_dp = *max_element(dp.begin(),dp.end());
        ll maxfree = maxsumk[i+1];
        ans = max(ans,max_dp+maxfree);
    }

    cout<<ans<<endl;

    return;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    // int t;
    // cin >> t;
    // while (t--) {
    //     solve();
    // }
    solve();
    return 0;
}
